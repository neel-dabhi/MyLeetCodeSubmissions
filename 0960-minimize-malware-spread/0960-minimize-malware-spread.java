// TC: O(V + E)
// SC: O(V)
class Solution {
    int[] nodesColor;

    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;

        // node and its color
        nodesColor = new int[n];
        Arrays.fill(nodesColor, -1);
        int cl = 0;
        for (int i = 0; i < n; i++) {
            dfs(graph, i, cl);
            cl++;
        }

        // count how may in color group
        int[] countInGroup = new int[cl];
        for (int i = 0; i < n; i++) {
            countInGroup[nodesColor[i]]++;
        }
        // count how may infected in a group
        int[] infectedCountInGroup = new int[cl];
        for (int infectedNode : initial) {
            infectedCountInGroup[nodesColor[infectedNode]]++;
        }

        int result = Integer.MAX_VALUE;

        for(int node: initial){
            if(infectedCountInGroup[nodesColor[node]] == 1){
                if(result == Integer.MAX_VALUE){
                    result = node;
                }else if( countInGroup[nodesColor[node]] > countInGroup[nodesColor[result]]){
                    result = node;
                }else if(countInGroup[nodesColor[node]] == countInGroup[nodesColor[result]]){
                    result = Math.min(result, node);
                }
            }
        }

        if(result == Integer.MAX_VALUE){
            for(int node: initial){
                result = Math.min(result, node);
            }
        }

        return result;

    }

    private void dfs(int[][] graph, int i, int color) {
        // base
        if (nodesColor[i] != -1) {
            return;
        }

        nodesColor[i] = color;

        for (int j = 0; j < graph.length; j++) {
            if (i != j && graph[i][j] == 1) {
                dfs(graph, j, color);
            }
        }

    }
}